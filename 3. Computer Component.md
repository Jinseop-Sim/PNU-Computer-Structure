# Computer Component
---
> 앞서 배웠던 von Neumann Architecture의 3가지 특징을 다시 생각해보자.  

1. Data와 Instruction은 단일 R/W Memory에 저장된다.
2. Memory들은 주소로 위치 정보가 저장되며, Data의 Type도 여기에 포함된다.
3. 모든 실행은 순차적으로 진행된다.

## System Component
- CPU : 명령어를 해석하고 실행하는 역할, 산술 연산 및 논리 연산이 가능하다.
  - Control Unit : Code를 받아들이며, 문제 발생시 신호를 보내는 제어 장치
  - ALU(Arithmmetic and Logic Unit) : 연산을 담당하는 장치
  - CPU Registers
    - PC(Program Counter) : 다음에 실행될 명령어의 주소를 가리키는 Register
    - IR(Instruction Register) : 현재 실행중인 명령어
    - MAR(Memory Address Register) : 다음에 쓰거나 읽어야 할 Memory의 주소
    - MBR(Memory Buffer Register) : Memory에서 읽어온 쓰거나 읽어야 할 Data들
    - I/O AR : I/O 장치
    - I/O BR : CPU와 I/O 장치 사이에서 Data를 교환해주는 장치
- Memory : 순차적으로 숫자가 배정된, 주소의 집합체
- I/O modules : Buffer을 포함하고 있는, CPU와 Memory 간의 Data 교환을 위해 잠시 묶어두는 장치
- Top level view  
![image](https://user-images.githubusercontent.com/71700079/159397940-bee3cea2-c04e-43a4-b2da-3aed06ffcebb.png)  

## Instruction Cycle
- Instruction Cycle = Fetch Cycle + Execution Cycle
- Fetch : CPU가 Memory에서 명령어를 읽어오는 것
  - 그럼 다음 명령어가 어떤 게 실행될지 어떻게 아나요?
    - PC(Program Counter)가 다음 Fetch 될 명령어의 주소를 갖고 있다.
    - Fetch된 명령어는 IR(Instruction Register)에 저장된다.
- Execution : 실행 단계  
  - Processor-Memory : CPU와 Main memory 간의 데이터 교환
  - Processor I/O : CPU와 I/O module 간의 데이터 교환
  - Data Processing : 데이터에 산술 및 논리 연산을 진행하는 것
  - Control : 분기문, 조건문 등에 의한 제어 연산
![image](https://user-images.githubusercontent.com/71700079/159398057-c2dd47e8-41c3-4efd-bfbe-1c2ad43fd0c2.png)  

## Interrupts
> 어떤 오류가 발생했을 때, 그것을 인지하고 작업을 중단하기 위해 신호를 보내는 것.  

- Interrupts는 Process들을 효율적으로 운용하고 효율적인 자원의 사용을 위해 반드시 필요하다.
- Program
  - ex) Overflow, DBZ
- Timer
  - Processor Timer에 의해 주기적으로 보내지는 신호
  - preemptive한 multi-tasking을 할 때 쓰인다.
- I/O
  - I/O controller에 의해 I/O의 완료나 오류를 알리는 신호
- Hardware Failure
  - ex) Memory parity error, Power failure
- 아래는 Interrupt가 추가된 Instruction Cycle이다.  
![image](https://user-images.githubusercontent.com/71700079/159398694-5fd639b6-ee1b-4d72-998b-fdca3b20801f.png)  

### Interrupt Cycle
- CPU가 Interrupt의 발생을 Check한다.
  - Interrupt Signal을 통해 판단한다.
- Interrupt가 없으면? 다음 명령어 실행.
- Interrupt가 있으면?
  - 현재 Program의 실행을 중단한다.
  - 현재 CPU의 상태(Context)를 저장한다.
  - PC(Program Counter)를 Interrupt Handler의 주소로 옮긴다.
  - Interrupt를 진행한 뒤, 저장했던 Context를 복구해 다음 명령어 자리로 Return한다.
- __명령어는 Atomic해서, 해당 명령을 중단할 수는 없다. 즉, 하나의 명렁어가 끝나고 다음 명령어를 Fetch하기 전에 Interrupt를 Handle하는 것!__

### Multiple Interrupts
- Sequential Approach
  - Interrupts가 발생했을 때, 또 다른 Interrupts가 발생하면?
  - 한 Interrupts가 처리중일 때, CPU는 다른 Interrupt들을 무시하도록 되어있다.
  - 마치 순차적으로 처리하는 것처럼 보인다.
- Nested Approach : Define priorities
  - 낮은 우선순위의 Interrupts는 높은 우선순위의 Interrupts에 의해 발생할 수 있다.
  - 높은 우선순위의 Interrupts가 Return 할 땐, 낮은 우선순위의 Interrupts가 중단됐던 부분으로 Return된다.
  ![image](https://user-images.githubusercontent.com/71700079/160427443-571c6637-b79a-4bb3-b20f-557ac5fa70a9.png)   
  - 위의 사진 속 우선순위는 __Communication > Disk > Printer__ 순으로 높다.
    - Disk가 Communication에 의해 Pending 되었으므로, Communication의 우선순위가 더 높음을 알 수 있다.

## Interconnection Structure
> 모든 Unit들은 연결되어있다.  
- Interconnection Structure : System 모듈들을 연결하는 경로들의 집합
- Data Transfer
  - Memory => CPU | CPU => Memory
  - I/O => CPU | CPU => I/O
  - I/O <=> Memory (DMA : Direct Memory Access)
 
### Computer Modules
- Memory  
![image](https://user-images.githubusercontent.com/71700079/160429417-085656b7-8236-4228-857d-15ca65ed31ba.png)  
  - 어느 Memory에 접근할 것인지 Address를 받아야 한다.
  - Memory에 저장할 Data를 받을 수도 있고, 꺼내달라고 요청받은 Data를 꺼내줄 수도 있다.  
 
- I/O Module  
![image](https://user-images.githubusercontent.com/71700079/160429491-d86a3c63-0ba8-4753-ad92-68bcdc0202e2.png)  
  - CPU와 통신하는 Internal Data와 실제 I/O 장치들과 통신하는 External Data가 있다.
  - 어디에 입력할 것인지, 어디에 있는 것을 출력할 것인지 Address를 받아야 한다.
  - Interrupt Signal을 보내, 앞서 배웠듯이 Interrupt Handling을 통한 I/O를 받는다.  

- CPU  
![image](https://user-images.githubusercontent.com/71700079/160429545-13a5178a-ce24-407d-8295-59a0876c61d4.png)  
  - 실행항 Instructions를 받는다.
  - Interrupt Signals를 받고 Interrput를 발생시킨다.
 

